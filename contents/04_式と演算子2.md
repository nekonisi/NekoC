04\_式と演算子
---

## 代入演算子の評価のタイミング

### サンプルコード

```assignmentOperator.c:C

#include <stdio.h>
#include <stdlib.h>

int main()
{
	int a1, a2, a3, a4;

	a1 = 5;
	a1 = a1 + 2;
	printf("----------------------\n");
	printf("a1 = 5;\n");
	printf("a1 = a1 + 2;\n");
	printf("----------------------\n");
	printf("a1 = %d\n", a1);

	a2 = 5;
	a2 += 2;
	printf("----------------------\n");
	printf("a2 = 5;\n");
	printf("a2 += 2;\n");
	printf("----------------------\n");
	printf("a2 = %d\n", a2);

	a3 = 5;
	a3 = a3++ + 2;
	printf("----------------------\n");
	printf("a3 = 5;\n");
	printf("a3 = a3++ + 2;\n");
	printf("----------------------\n");
	printf("a3 = %d\n", a3);

	a4 = 5;
	printf("----------------------\n");
	printf("a4 = 5;\n");
	printf("表示時に a4++ + 2 する。\n");
	printf("----------------------\n");
	printf("a4 = %d\n", a4++ + 2);

	system("pause");
	return 0;
}

```

### 出力結果

```output

----------------------
a1 = 5;
a1 = a1 + 2;
----------------------
a1 = 7
----------------------
a2 = 5;
a2 += 2;
----------------------
a2 = 7
----------------------
a3 = 5;
a3 = a3++ + 2;
----------------------
a3 = 8
----------------------
a4 = 5;
表示時に a4++ + 2 する。
----------------------
a4 = 7
続行するには何かキーを押してください . . .

```

## キャスト演算子

- cast: 鋳造する。-> 無理やりはめる。
- キャスト演算子
  - `(型名X)式` : 式にギプスを巻いて無理やり別の型にしている。
	
### サンプルコード

```cast.c:C

#include <stdio.h>
#include <stdlib.h>

int main()
{
	int _int1 = 10, _int2 = 4;
	double _double;

	_double = _int1 / _int2;

	printf("%d ÷ %d = %f･･･(1)\n", _int1, _int2, _int1 / _int2);
	printf("%d ÷ %d = %f･･･(2)\n", _int1, _int2, _double);
	printf("%d ÷ %d = %f･･･(3)\n", _int1, _int2, (double)_int1/_int2);

	system("pause");

	return 0;

}

```

### 出力結果

```output

10 ÷ 4 = 0.000000･･･(1)
10 ÷ 4 = 2.000000･･･(2)
10 ÷ 4 = 2.500000･･･(3)
続行するには何かキーを押してください . . .

```

- (1)
  - int型を`%f`で表現しようとしている。
- (2)
  - `_int1 / _int2`はint型になるが、それをdouble型に代入している。
	- `a = b`ではどのような型であってもaの型になる。
- (3)
  - `_int1`がdouble型にキャストされたため、解もdouble型になった。
	- ※ 計算された場合、より大きな型に合わせられる。

## ビット演算子(ビット論理演算子)

|演算子|意味                          |
|------|------------------------------|
|&     |ビット積演算子。どちらも1なら1|
|\|    |ビット和演算子。どちらか1なら1|
|^     |ビット差演算子。異なれば1     |

### サンプルコード

```bitOperate.c:C

#include <stdio.h>
#include <stdlib.h>

int main(){

	unsigned short a, b;

	a= 1;
	b = 3;

	printf("-----------------------------\n");
	printf(" a      = 0000 0000 0000 0001\n");
	printf(" b      = 0000 0000 0000 0011\n");
	printf(" a & b  = 0000 0000 0000 0001\n");
	printf("-----------------------------\n");
	printf("積 a & b = %d\n", a & b);
	printf("\n\n");


	printf("-----------------------------\n");
	printf(" a      = 0000 0000 0000 0001\n");
	printf(" b      = 0000 0000 0000 0011\n");
	printf(" a | b  = 0000 0000 0000 0011\n");
	printf("-----------------------------\n");
	printf("和 a | b = %d\n", a | b);
	printf("\n\n");


	printf("-----------------------------\n");
	printf(" a      = 0000 0000 0000 0001\n");
	printf(" b      = 0000 0000 0000 0011\n");
	printf(" a ^ b  = 0000 0000 0000 0010\n");
	printf("-----------------------------\n");
	printf("差 a ^ b = %d\n", a ^ b);
	printf("\n\n");

	system("pause");
	return 0;
}

```

### 出力結果

```output

-----------------------------
 a      = 0000 0000 0000 0001
 b      = 0000 0000 0000 0011
 a & b  = 0000 0000 0000 0001
-----------------------------
積 a & b = 1


-----------------------------
 a      = 0000 0000 0000 0001
 b      = 0000 0000 0000 0011
 a | b  = 0000 0000 0000 0011
-----------------------------
和 a | b = 3


-----------------------------
 a      = 0000 0000 0000 0001
 b      = 0000 0000 0000 0011
 a ^ b  = 0000 0000 0000 0010
-----------------------------
差 a ^ b = 2


続行するには何かキーを押してください . . .

```

### サンプルコード2

```bitOperate2:C

#define CAT 1 /*CATを1と定義*/
#define DOG 2 /*CATを1と定義*/
#define RAT 4 /*CATを1と定義*/
#define RABBIT 8 /*CATを1と定義*/

# include <stdio.h>
# include <stdlib.h>

int main()
{
	int aPet = CAT | DOG; /*Aさんのペット*/
	int bPet = RAT; /*Bさんのペット*/
	int cPet = CAT | DOG | RAT | RABBIT; /*Cさんのペット*/
	int dPet = DOG | RAT; /*Dさんのペット*/

	printf("Aさんのペット(猫=%d, 犬=%d, ネズミ=%d, ウサギ=%d)\n",
		(aPet & CAT) != 0, (aPet & DOG) != 0, (aPet & RAT) != 0, (aPet & RABBIT) != 0);

	printf("Bさんのペット(猫=%d, 犬=%d, ネズミ=%d, ウサギ=%d)\n",
		(bPet & CAT) != 0, (bPet & DOG) != 0, (bPet & RAT) != 0, (bPet & RABBIT) != 0);

	printf("Cさんのペット(猫=%d, 犬=%d, ネズミ=%d, ウサギ=%d)\n",
		(cPet & CAT) != 0, (cPet & DOG) != 0, (cPet & RAT) != 0, (cPet & RABBIT) != 0);

	printf("Dさんのペット(猫=%d, 犬=%d, ネズミ=%d, ウサギ=%d)\n",
		(dPet & CAT) != 0, (dPet & DOG) != 0, (dPet & RAT) != 0, (dPet & RABBIT) != 0);

	system("pause");

	return 0;
}

```

### 出力結果

```

Aさんのペット(猫=1, 犬=1, ネズミ=0, ウサギ=0)
Bさんのペット(猫=0, 犬=0, ネズミ=1, ウサギ=0)
Cさんのペット(猫=1, 犬=1, ネズミ=1, ウサギ=1)
Dさんのペット(猫=0, 犬=1, ネズミ=1, ウサギ=0)
続行するには何かキーを押してください . . .

```

### 解説

- aPetを元に解説
  - CAT    : 1 -> 00000001
  - DOG    : 2 -> 00000010
  - RAT    : 4 -> 00000100
  - RABBIT : 8 -> 00001000
- `aPet = CAT | DOG` -> `aPet = 00000011`
- aPet & CAT

```
  aPet       = 00000011
  CAT        = 00000001
  aPet & CAT = 00000001

```

```
  aPet       = 00000011
  DOG        = 00000010
  aPet & CAT = 00000010

```

```
  aPet       = 00000011
  RAT        = 00000100
  aPet & CAT = 00000000

```

```
  aPet          = 00000011
  RABBIT        = 00001000
  aPet & RABBIT = 00000000

```

to be continued
